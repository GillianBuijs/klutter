/* Copyright (c) 2021 - 2022 Buijs Software
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package dev.buijs.klutter.core.tasks.adapter.dart


import dev.buijs.klutter.core.*

private const val BR = "\n"

/**
 * @author Gillian Buijs
 */
internal class DartPrinter(private val objects: DartObjects): KlutterPrinter {

    override fun print(): String {

        val messages = objects.messages.joinToString(BR + BR) {
            MessagePrinter(it).print()
        }

        val enumerations = objects.enumerations.joinToString(BR + BR) {
            EnumerationPrinter(it).print()
        }

        return """
           |/// Autogenerated by Klutter
           |/// Do net edit directly, 
           |/// but recommended to store in VCS.
           |$messages
           |
           |$enumerations
           |
        """.trimMargin()
    }

}

/**
 * Prints all members of a class.
 *
 * @author Gillian Buijs
 */
internal class EnumerationPrinter(private val message: DartEnum): KlutterPrinter {

    override fun print() = "" +
            "class ${message.name} {$BR" +
            "final String string;$BR$BR" +
            "const ${message.name}._(this.string);" +
             printValues(message) +
            "  static const none = ${message.name}._('none');$BR" +
            BR + BR +
            "static const values = [${message.values.joinToString(",") { toCamelCase(it) }}];$BR$BR" +
            "  @override$BR" +
            "  String toString() {$BR" +
            "    return '${message.name}.\$string';\n" +
            "  }$BR" +
            EnumExtensionPrinter(message).print() +
            "}$BR"

    private fun printValues(message: DartEnum): String {

        val sb = StringBuilder()

        val jsonValues = if(message.jsonValues.size == message.values.size) message.jsonValues else message.values

        message.values.forEachIndexed { index, s ->
            sb.append("  static const ${toCamelCase(s)} = ${message.name}._('${jsonValues[index]}');$BR")
        }

        return sb.toString()

    }

}

/**
 * Prints all members of a class.
 *
 * @author Gillian Buijs
 */
internal class EnumExtensionPrinter(private val message: DartEnum): KlutterPrinter {

    override fun print() = """
        |
        |  static ${message.name} fromJson(String value) {
        |    switch(value) {${cases()}
        |      default: return ${message.name}.none;
        |    }
        | }
        |
        |  String? toJson() {
        |    switch(this) { ${serializers()}
        |      default: return null;
        |    }
        |  }
        |
    """.trimMargin()

    private fun cases(): String {
        if(message.jsonValues.isEmpty()) {
            return message.values.joinToString(";") {
                "$BR      case \"$it\": return ${message.name}.${toCamelCase(it)}"
            } + ";"
        }

        var print = ""
        message.jsonValues.forEachIndexed { index, json ->
            print += "$BR      case \"$json\": return ${message.name}.${toCamelCase(message.values[index])};"
        }

        return print
    }

    private fun serializers(): String {
        if(message.jsonValues.isEmpty()) {
            return message.values.joinToString(";") {
                "$BR      case ${message.name}.${toCamelCase(it)}: return \"$it\""
            }  + ";"
        }

        var print = ""
        message.jsonValues.forEachIndexed { index, json ->
            print += "$BR      case ${message.name}.${toCamelCase(message.values[index])}: return \"$json\";"
        }

        return print
    }

}

internal fun toCamelCase(snake: String): String {

    var hasUnderscore = false

    return snake.lowercase().map {
         when {

            it == '_' -> {
                hasUnderscore = true
                ""
            }

            hasUnderscore -> {
                hasUnderscore = false
                it.uppercase()
            }

            else -> it.toString()
        }
    }.joinToString("") { it }

}

/**
 * Prints all members of a class.
 *
 * @author Gillian Buijs
 */
internal class MessagePrinter(private val message: DartMessage): KlutterPrinter {

    override fun print() = """
        |
        |class ${message.name} {
        |  
        |${ConstructorPrinter(message).print()}
        |  
        |${FactoryPrinter(message).print()}
        |
        |${MemberPrinter(message.fields).print()}
        |
        |${SerializerPrinter(message.fields).print()}  
        |}
    """.trimMargin()

}

/**
 * Prints the class constructor
 *
 * @author Gillian Buijs
 */
internal class ConstructorPrinter(
    private val message: DartMessage
    ): KlutterPrinter {

    override fun print() =
        "" +
        "  ${message.name}({$BR" +
        "${message.fields.sortedBy { it.optional }.joinToString(BR){ printField(it) }}$BR" +
        "  });"

    private fun printField(field: DartField) =
        StringBuilder().also { sb ->
            sb.append("    ")

            if(!field.optional) {
                sb.append("required ")
            }

            sb.append("this.${field.name},")

        }.toString()

}

/**
 * Prints the factory method.
 *
 * @author Gillian Buijs
 */
internal class FactoryPrinter(
    private val message: DartMessage
): KlutterPrinter {

    override fun print() = "" +
            "factory ${message.name}.fromJson(dynamic json) {$BR" +
            "   return ${message.name} ($BR" +
            "${message.fields.joinToString(BR) { printField(it) }}$BR" +
            "   );$BR" +
            " }"


    private fun printField(field: DartField) =
        StringBuilder().also { sb ->

            val isList = field.isList
            val isNullable = field.optional
            val q = if(isNullable) "?" else ""

            sb.append("     ")
            sb.append("${field.name}: ")

            if(isList) {
                procesAsList(
                    sb = sb,
                    isNullable = isNullable,
                    field = field,
                )
            } else {
                val dataType = toDataType(field)
                if(field.customDataType != null){
                    sb.append("$dataType.fromJson(json['${field.name}'])")
                } else sb.append("json['${field.name}']$q${getCastMethod(dataType)}")
            }
            sb.append(",")

        }.toString()

    private fun procesAsList(
        sb: StringBuilder,
        isNullable: Boolean,
        field: DartField,
    ) {

        if(isNullable) sb.append("json['${field.name}'] == null ? [] : ")

        val dataType = toDataType(field)
        sb.append("List<${dataType}>")
        sb.append(".from(json['${field.name}']")

        val q = if(isNullable) "?" else ""

        if(field.customDataType != null){
            sb.append("$q.map((o) => ${dataType}.fromJson(o)))")
        } else sb.append("$q.map((o) => o${getCastMethod(dataType)}))")

    }
}

internal fun getCastMethod(dataType: String) = when(DartKotlinMap.toMap(dataType)) {
    DartKotlinMap.BOOLEAN -> ""
    DartKotlinMap.DOUBLE -> ".toDouble()"
    DartKotlinMap.INTEGER -> ".toInt()"
    DartKotlinMap.STRING -> ".toString()"
}

/**
 * Prints the fields of a class.
 *
 * @author Gillian Buijs
 */
internal class MemberPrinter(
    private val fields: List<DartField>
): KlutterPrinter {

    override fun print() = fields.sortedBy { it.optional }.joinToString(BR) {
        var datatype = toDataType(it)

        if(it.isList){
            datatype = "List<${toDataType(it)}>"
        }

        if(it.optional) {
            " $datatype? ${it.name};"
        } else " final $datatype ${it.name};"
    }

}

/**
 * Prints the toJson method.
 *
 * @author Gillian Buijs
 */
internal class SerializerPrinter(
    private val fields: List<DartField>
): KlutterPrinter {

    override fun print() =
        " Map<String, dynamic> toJson() {$BR" +
        "   return {$BR" +
        "|${fields.joinToString(",$BR") { "     '${it.name}': ${serializer(it)}" }}$BR" +
        "   };$BR" +
        " }"

    private fun serializer(field: DartField): String {
        val q = if(field.optional) "?" else ""
        var out = field.name

        if(field.isList) {

            field.customDataType?.let {

                if(field.isList) {
                    out += "$q.map((o) => o.toJson())"
                }

            }

            out += ".toList()"
        } else field.customDataType?.let { out = "$out.toJson()" }

        return out
    }
}

internal fun toDataType(field: DartField) = field.customDataType?:field.dataType