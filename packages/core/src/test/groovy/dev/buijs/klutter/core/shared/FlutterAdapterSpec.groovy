package dev.buijs.klutter.core.shared

import dev.buijs.klutter.core.Method
import spock.lang.Specification

class FlutterAdapterSpec extends Specification {

    def "Verify the FlutterAdapterPrinter creates the GeneratedAdapter with a branch for each KlutterAdaptee annotation"() {

        given:
        def definitions = [
                new Method(
                        "doFooBar",
                        "io.foo.bar.FooBar",
                        "FooBar().zeta()",
                        false,
                        "String",
                ),
                new Method(
                        "notDoFooBar",
                        "io.foo.bar.FooBar",
                        "FooBar().beta()",
                        false,
                        "int",
                ),
                new Method(
                        "complexityGetter",
                        "io.foo.bar.ComplexFoor",
                        "ComplexFoo().bar()",
                        false,
                        "List<Complex>",
                )
        ]

        when:
        def actual = new FlutterAdapterPrinter(
                "KLUTTER", "Adapter", definitions, [], []
        ).print()

        then:
        actual.replaceAll(" ", "").replaceAll("\n", "") == """
                        import 'dart:convert';
                        import 'dart:async';
                        import 'package:flutter/services.dart';

                        /// Autogenerated by Klutter Framework.
                        ///
                        /// Do net edit directly, but recommended to store in VCS.
                        ///
                        /// Adapter class which handles communication with the KMP library.
                        class Adapter {
                          static const MethodChannel _channel = MethodChannel('KLUTTER');

                          static Future<AdapterResponse<String>> get doFooBar async {
                            try {
                              final json = await _channel.invokeMethod('doFooBar');
                              return AdapterResponse.success(json.toString());
                            } catch (e) {
                              return AdapterResponse.failure(
                                e is Error ? Exception(e.stackTrace) : e as Exception
                              );
                            }
                          }

                          static Future<AdapterResponse<int>> get notDoFooBar async {
                            try {
                              final json = await _channel.invokeMethod('notDoFooBar');
                              return AdapterResponse.success(json.toInt());
                            } catch (e) {
                              return AdapterResponse.failure(
                                e is Error ? Exception(e.stackTrace) : e as Exception
                              );
                            }
                          }

                          static Future<AdapterResponse<List<Complex>>> get complexityGetter async {
                            try {
                              final response = await _channel.invokeMethod('complexityGetter');
                              final json = jsonDecode(response);
                              return AdapterResponse.success(List<Complex>.from(json.map((o) => Complex.fromJson(o))));
                            } catch (e) {
                              return AdapterResponse.failure(
                                e is Error ? Exception(e.stackTrace) : e as Exception
                              );
                            }
                          }

                        }

                        /// Autogenerated by Klutter Framework.
                        ///
                        /// Do net edit directly, but recommended to store in VCS.
                        ///
                        /// Wraps an [exception] if calling the platform method has failed to be logged by the consumer.
                        /// Or wraps an [object] of type T when platform method has returned a response and
                        /// deserialization was successful.
                        class AdapterResponse<T> {

                          AdapterResponse(this._object, this._exception);

                          factory AdapterResponse.success(T t) => AdapterResponse(t, null);

                          factory AdapterResponse.failure(Exception e) => AdapterResponse(null, e);

                          ///The actual object to returned
                          T? _object;
                            set object(T object) => _object = object;
                            T get object => _object!;

                          ///Exception which occurred when calling a platform method failed.
                          Exception? _exception;
                            set exception(Exception e) => _exception = e;
                            Exception get exception => _exception!;

                          bool isSuccess() {
                            return _object != null;
                          }

                        }
                        """.replaceAll(" ", "").replaceAll("\n", "")
    }
}