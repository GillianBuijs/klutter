import 'dart:async';
import 'dart:convert';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';
import 'package:klutter/klutter.dart';

/// Autogenerated by Klutter Framework.
///
/// Do net edit directly, but recommended to store in VCS.
///
/// Adapter class which handles communication with the KMP library.
class SuperAwesome {
  static const MethodChannel _channel = MethodChannel('foo.bar.super_awesome');


  static Future<AdapterResponse<String>> DartMaul(State caller, {
    void Function(String)? onSuccess,
    void Function(Exception)? onFailure,
    void Function()? onNullValue,
    void Function(AdapterResponse<String>)? onComplete,
  }) async {

    try {
    final json = await _channel.invokeMethod('DartMaul');
      final value = json.toString();
      final AdapterResponse<String> response =
          AdapterResponse.success(value);

      if(caller.mounted) {
        onComplete?.call(response);
          onSuccess?.call(value);
      }

      return response;

    } catch (e) {

      final exception = e is Error
          ? Exception(e.stackTrace)
          : e as Exception;

      final AdapterResponse<String> response =
          AdapterResponse.failure(exception);

      if(caller.mounted) {
        onComplete?.call(response);
        onFailure?.call(exception);
      }

      return response;
    }
  }

  static Future<AdapterResponse<List<String>>> BabyYoda(State caller, {
    void Function(List<String>)? onSuccess,
    void Function(Exception)? onFailure,
    void Function()? onNullValue,
    void Function(AdapterResponse<List<String>>)? onComplete,
  }) async {

    try {

               final jsonResponse = await _channel.invokeMethod('BabyYoda');
      final json = jsonDecode(jsonResponse);
      final value = List<String>.from(json.map((o) => o.toString()));
      final AdapterResponse<List<String>> response =
          AdapterResponse.success(value);

      if(caller.mounted) {
        onComplete?.call(response);
          onSuccess?.call(value);
      }

      return response;

    } catch (e) {

      final exception = e is Error
          ? Exception(e.stackTrace)
          : e as Exception;

      final AdapterResponse<List<String>> response =
          AdapterResponse.failure(exception);

      if(caller.mounted) {
        onComplete?.call(response);
        onFailure?.call(exception);
      }

      return response;
    }
  }

  static Future<AdapterResponse<List<String>>> ObiWan(State caller, {
    void Function(List<String>)? onSuccess,
    void Function(Exception)? onFailure,
    void Function()? onNullValue,
    void Function(AdapterResponse<List<String>>)? onComplete,
  }) async {

    try {

               final jsonResponse = await _channel.invokeMethod('ObiWan');
      final json = jsonDecode(jsonResponse);
      final value = List<String>.from(json.map((o) => o.toString()));
      final AdapterResponse<List<String>> response =
          AdapterResponse.success(value);

      if(caller.mounted) {
        onComplete?.call(response);
          onSuccess?.call(value);
      }

      return response;

    } catch (e) {

      final exception = e is Error
          ? Exception(e.stackTrace)
          : e as Exception;

      final AdapterResponse<List<String>> response =
          AdapterResponse.failure(exception);

      if(caller.mounted) {
        onComplete?.call(response);
        onFailure?.call(exception);
      }

      return response;
    }
  }

}




