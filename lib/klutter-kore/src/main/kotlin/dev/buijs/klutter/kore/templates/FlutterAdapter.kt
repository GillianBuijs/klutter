/* Copyright (c) 2021 - 2022 Buijs Software
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
package dev.buijs.klutter.kore.templates

import dev.buijs.klutter.kore.shared.DartField
import dev.buijs.klutter.kore.KlutterPrinter
import dev.buijs.klutter.kore.ast.StandardTypeMap
import dev.buijs.klutter.kore.shared.*
import dev.buijs.klutter.kore.shared.toCamelCase
import dev.buijs.klutter.kore.shared.unwrapFromList

private const val BR = "\n"

/**
 * Output the main dart file which delegates platform calls to the Kotlin Multiplatform code.
 */
class FlutterAdapter(
    private val pluginClassName: String = "Adapter",
    private val methodChannelName: String = "KLUTTER",
    private val methods: List<Method>,
    private val messages: List<DartMessage>,
    private val enumerations: List<DartEnum>,
): KlutterPrinter {

    /**
     * Will add line <b>import 'dart:convert';</b> if methods contains
     * any datatype that is not standard e.g. if dart convert library
     * is needed to convert JSON to an object.
     */
    private val needConvertImport = methods
        .map { StandardTypeMap.toMapOrNull(it.dataType) }
        .any { dkm -> dkm == null }

    override fun print(): String = """
            |import 'dart:async';
            ${if(needConvertImport) "|import 'dart:convert';" else ""}
            |import 'package:flutter/services.dart';
            |import 'package:flutter/widgets.dart';
            |import 'package:klutter/klutter.dart';
            |
            |/// Autogenerated by Klutter Framework. 
            |/// 
            |/// Do net edit directly, but recommended to store in VCS.
            |/// 
            |/// Adapter class which handles communication with the KMP library.
            |class $pluginClassName {
            |  static const MethodChannel _channel = MethodChannel('$methodChannelName');
            |  
            ${methods.joinToString(BR) { it.asFunctionString() }}
            |
            |}
            |
            |${messages.asMessagesString()}
            |
            |${enumerations.asEnumerationsString()}
            |
            """.trimMargin()



    private fun Method.asFunctionString(): String {

        val standardTypeOrNull = StandardTypeMap.toMapOrNull(dataType)

        /**
         * Standard types don't need to be decoded.
         */
        val doJsonDecode = standardTypeOrNull == null

        /**
         * A void function returns null.
         */
        val isVoid = standardTypeOrNull == StandardTypeMap.NOTHING

        val invokeMethod = when {
            doJsonDecode -> {
                """final jsonResponse = await _channel.invokeMethod('${methodId}');
                   |      final json = jsonDecode(jsonResponse);
                   |"""
            }

            isVoid -> "await _channel.invokeMethod('${methodId}');\n"

            else -> "final json = await _channel.invokeMethod('${methodId}');\n"
        }

        val serializerOrBlank = if(isVoid) "" else "      final value = ${serializer()};"

        return """
                   |  static Future<AdapterResponse<${dataType}>> $command({
                   |    State? caller,
                   |    void Function(${if(isVoid) "" else dataType})? onSuccess,
                   |    void Function(Exception)? onFailure,
                   |    void Function()? onNullValue,
                   |    void Function(AdapterResponse<${dataType}>)? onComplete,
                   |  }) async {
                   |
                   |    try {
                   |    """ + invokeMethod + serializerOrBlank + """      
                   |      final AdapterResponse<${dataType}> response = 
                   |          AdapterResponse.success(${if(isVoid) "null" else "value"});
                   |
                   |      if(caller?.mounted ?? false) {
                   |        onComplete?.call(response);""" +
                if(nullable) {
                    """        
                    |        if(value == null) {
                    |          onNullValue?.call();
                    |        } else {
                    |          onSuccess?.call(value!);
                    |        }"""
                } else if(isVoid) {
                    """      
                    |          onSuccess?.call();
                    |"""
                } else {
                    """      
                    |          onSuccess?.call(value);
                    |"""
                } + """
                   |      }
                   |
                   |      return response;
                   |      
                   |    } catch (e) {
                   |      
                   |      final exception = e is Error 
                   |          ? Exception(e.stackTrace) 
                   |          : e as Exception;
                   |      
                   |      final AdapterResponse<${dataType}> response = 
                   |          AdapterResponse.failure(exception);
                   |
                   |      if(caller?.mounted ?? false) {
                   |        onComplete?.call(response);
                   |        onFailure?.call(exception);
                   |      }
                   |
                   |      return response;
                   |    }
                   |  }""".trimMargin()

    }

    private fun Method.serializer(): String {

        // Maybe get the data type nested within 'List<...>'
        val type = dataType.unwrapFromList()

        // If unwrapping returned dataType then it is not a List
        val isList = type != dataType

        //Standard DART datatype
        return if(isList) type.asList(nullable) else type.asString(nullable)

    }

    private fun String.asList(nullable: Boolean): String {

        val q = if(nullable) "?" else ""

        return if(StandardTypeMap.toMapOrNull(this) == null) {
            "List<$this>.from(json$q.map((o) => $this.fromJson(o)))"
        } else {
            "List<$this>.from(json$q.map((o) => o${getCastMethod(this)}))"
        }
    }

    private fun String.asString(nullable: Boolean): String {

        val q = if(nullable) "?" else ""

        return if(StandardTypeMap.toMapOrNull(this) == null) {
            "$this$q.fromJson(json)"
        } else {
            "json$q${getCastMethod(this)}"
        }
    }
}

/**
 * Prints all members of a class.
 */
internal class EnumerationPrinter(private val message: DartEnum): KlutterPrinter {

    override fun print() =
        """|class ${message.name} {
           |final String string;
           |
           |const ${message.name}._(this.string);
           |
           |${message.printValues()}
           |  static const none = ${message.name}._('none');
           |  
           |  static const values = [${message.values.joinToString(",") { it.toCamelCase()}}];
           |  
           |  @override
           |  String toString() {
           |      return '${message.name}.${'$'}string';
           |  }
           |  
           |  ${EnumExtensionPrinter(message).print()}
           |  
           |}
        """.trimMargin()

    private fun DartEnum.printValues(): String = chooseValues()
        .map { entry ->
            "  static const ${entry.key.toCamelCase()} = ${name}._('${entry.value}');" }
        .joinToString(BR) { it }

}

internal fun List<DartMessage>.asMessagesString(): String {
    return joinToString(BR + BR) {
        MessagePrinter(it).print()
    }
}

internal fun List<DartEnum>.asEnumerationsString(): String {
    return joinToString(BR + BR) {
        EnumerationPrinter(it).print()
    }
}

/**
 * Prints all members of a class.
 */
internal class EnumExtensionPrinter(private val message: DartEnum): KlutterPrinter {

    override fun print() = """
        |  static ${message.name} fromJson(String value) {
        |    switch(value) {
        |    ${message.cases()}
        |      default: return ${message.name}.none;
        |    }
        | }
        |
        |  String? toJson() {
        |    switch(this) { 
        |    ${message.serializers()}
        |      default: return null;
        |    }
        |  }
        |
    """.trimMargin()

    private fun DartEnum.cases(): String = chooseValues()
        .map { entry -> "      case \"${entry.value}\": return ${name}.${entry.key.toCamelCase()};" }
        .joinToString(BR) { it }

    private fun DartEnum.serializers(): String = chooseValues()
        .map { entry -> "      case ${name}.${entry.key.toCamelCase()}: return \"${entry.value}\";" }
        .joinToString(BR) { it }

}

/**
 * Merge enum values list to a map consisting of the enumeration key and JSON value (if present).
 *
 * If there are no JSON values or the JSON values count does not match the enumeration key count
 * then a map of key to key is returned.
 *
 * If JSON value count is equal to key count then map of enumeration key to JSON value is returned.
 */
private fun DartEnum.chooseValues(): Map<String, String> {
    val v = if(valuesJSON.size == values.size) valuesJSON else values
    return values.zip(v).toMap()
}

/**
 * Prints all members of a class.
 */
internal class MessagePrinter(
    private val message: DartMessage,
): KlutterPrinter {

    override fun print() = """
        |
        |class ${message.name} {
        |  
        |${message.asConstructorString()}
        |  
        |${FactoryPrinter(message).print()}
        |
        |${message.fields.asFieldsString()}
        |
        |${message.fields.asSerializerString()}  
        |}
    """.trimMargin()

}

/**
 * Prints the class constructor
 */
private fun DartMessage.asConstructorString() = fields
    .sortedBy { it.isOptional }
    .joinToString(BR){ ""
        .ifRequired(it) { _, _ -> "required " }
        .append { _ -> "this.${it.name}," }  }
    .let {
        """
        |  $name({
        |$it
        |  });
        """.trimMargin()
    }

/**
 * Prints the factory method.
 */
internal class FactoryPrinter(
    private val message: DartMessage
): KlutterPrinter {

    override fun print() =
        """ |factory ${message.name}.fromJson(dynamic json) {
            |   return ${message.name} (
            |${message.fields.joinToString(BR) { it.asFieldString() }}
            |   );
            | }   
        """.trimMargin()

    private fun DartField.asFieldString() = "      ${name}: "
        .ifList(this) { field, curr ->  field.asListString(curr) }
        .ifNotList(this) { field, curr ->  field.asString(curr) }
        .append { "," }

    private fun DartField.asListString(value: String): String = value
        .ifOptional(this) { _, curr -> "${curr}json['${name}'] == null ? [] : " }
        .append { "List<${type}>.from(json['${name}']" }
        .ifCustomType(this) { _, curr -> "$curr${this.opt()}.map((o) => ${type}.fromJson(o)))" }
        .ifStandardType(this) { _, curr -> "$curr${this.opt()}.map((o) => o${getCastMethod(type)}))" }

    private fun DartField.asString(value: String): String = value
        .ifCustomType(this) { _, curr -> "$curr$type.fromJson(json['${name}'])" }
        .ifStandardType(this) { _, curr -> "${curr}json['${name}']${this.opt()}${getCastMethod(type)}" }

}

internal fun getCastMethod(dataType: String) = when(StandardTypeMap.toMap(dataType)) {
    StandardTypeMap.DOUBLE -> ".toDouble()"
    StandardTypeMap.INTEGER -> ".toInt()"
    StandardTypeMap.STRING -> ".toString()"
    StandardTypeMap.NOTHING -> ""
    StandardTypeMap.BOOLEAN -> ""
    else -> throw Exception("not implemented yet") // TODO
}

/**
 * Print the fields of a message.
 */
private fun List<DartField>.asFieldsString() =
    sortedBy { it.isOptional }.joinToString(BR) { it.type
        .ifList(it) { field, _ -> "List<${field.type}>" }
        .ifOptional(it) { field, curr -> " $curr? ${field.name};" }
        .ifRequired(it) { field, curr -> " final $curr ${field.name};" }
    }

private fun String.ifList(
    field: DartField,
    closure: (field: DartField, value: String) -> String,
) = if(field.isList) closure.invoke(field, this) else this

private fun String.ifNotList(
    field: DartField,
    closure: (field: DartField, value: String) -> String,
) = if(!field.isList) closure.invoke(field, this) else this

private fun String.ifOptional(
    field: DartField,
    closure: (field: DartField, value: String) -> String,
) = if(field.isOptional) closure.invoke(field, this) else this

private fun String.ifRequired(
    field: DartField,
    closure: (field: DartField, value: String) -> String,
) = if(!field.isOptional) closure.invoke(field, this) else this

private fun String.ifCustomType(
    field: DartField,
    closure: (field: DartField, value: String) -> String,
) = if(field.isCustomType) closure.invoke(field, this) else this

private fun String.ifStandardType(
    field: DartField,
    closure: (field: DartField, value: String) -> String,
) = if(!field.isCustomType) closure.invoke(field, this) else this

private fun String.append(
    closure: (old: String) -> String,
) = "$this${closure.invoke(this)}"

/**
 * Print the toJson method.
 */
private fun List<DartField>.asSerializerString() = """
    | Map<String, dynamic> toJson() {
    |   return {
    ||${joinToString(",$BR") { "     '${it.name}': ${it.maybePostfixMapToList()}" }}    
    |   };
    | }   
    """.trimMargin()

private fun DartField.opt() = if(isOptional) "?" else ""

private fun DartField.maybePostfixMapToList() = when {

    !isList -> name.maybePostfixJson(this)

    isCustomType -> "$name${opt()}.map((o) => o.toJson()).toList()"

    else -> "$name${opt()}.toList()"

}

private fun String.maybePostfixJson(field: DartField): String =
    if(field.isCustomType) "$this${field.opt()}.toJson()" else this