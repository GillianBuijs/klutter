/* Copyright (c) 2021 - 2022 Buijs Software
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package dev.buijs.klutter.plugins.gradle.tasks.adapter.dart


import dev.buijs.klutter.core.*

private const val BR = "\r\n"

/**
 * @author Gillian Buijs
 */
class DartPrinter(private val objects: DartObjects): KlutterPrinter {

    override fun print(): String {

        val messages = objects.messages.joinToString(BR + BR) {
            MessagePrinter(it).print()
        }

        val enumerations = objects.enumerations.joinToString(BR + BR) {
            EnumerationPrinter(it).print()
        }

        val extensions = objects.enumerations.joinToString(BR + BR) {
            EnumExtensionPrinter(it).print()
        }

        return """
           |// Autogenerated by Klutter
           |// Do net edit directly, 
           |// but recommended to store in VCS.
           |
           |$messages
           |
           |$enumerations
           |
           |$extensions
           |
        """.trimMargin()
    }

}

/**
 * Prints all members of a class.
 *
 * @author Gillian Buijs
 */
internal class EnumerationPrinter(private val message: DartEnum): KlutterPrinter {

    override fun print() = "" +
            "enum ${message.name} {$BR" +
            printValues(message.values) +
            ",$BR" +
            "  none$BR" +
            "}$BR"

    private fun printValues(values: List<String>) = values.joinToString(",$BR") { "  ${toCamelCase(it)}" }

}

/**
 * Prints all members of a class.
 *
 * @author Gillian Buijs
 */
internal class EnumExtensionPrinter(private val message: DartEnum): KlutterPrinter {

    override fun print() = """
        |extension _${message.name} on ${message.name} {
        |
        |  static ${message.name} parse(String value) {
        |    switch(value) {${cases()};
        |      default: return ${message.name}.none;
        |    }
        | }
        |
        |  String? toJson() {
        |    switch(this) { ${serializers()};
        |      default: return null;
        |    }
        |  }
        |
        |}
    """.trimMargin()

    private fun cases() =
        message.values.joinToString(";") { "$BR      case \"$it\": return ${message.name}.${toCamelCase(it)}"}

    private fun serializers() =
        message.values.joinToString(";") { "$BR      case ${message.name}.${toCamelCase(it)}: return \"$it\""}

}

internal fun toCamelCase(snake: String): String {

    var hasUnderscore = false

    return snake.lowercase().map {
         when {

            it == '_' -> {
                hasUnderscore = true
                ""
            }

            hasUnderscore -> {
                hasUnderscore = false
                it.uppercase()
            }

            else -> it.toString()
        }
    }.joinToString("") { it }

}

/**
 * Prints all members of a class.
 *
 * @author Gillian Buijs
 */
internal class MessagePrinter(private val message: DartMessage): KlutterPrinter {

    override fun print() = """
        |class ${message.name} {
        |  
        |${ConstructorPrinter(message).print()}
        |  
        |${FactoryPrinter(message).print()}
        |
        |${MemberPrinter(message.fields).print()}
        |
        |${SerializerPrinter(message.fields).print()}  
        |}
    """.trimMargin()

}

/**
 * Prints the class constructor
 *
 * @author Gillian Buijs
 */
internal class ConstructorPrinter(
    private val message: DartMessage
    ): KlutterPrinter {

    override fun print() =
        "" +
        "|  ${message.name}({$BR" +
        "|${message.fields.sortedBy { it.optional }.joinToString(BR){ printField(it) }}$BR" +
        "  });"

    private fun printField(field: DartField) =
        StringBuilder().also { sb ->
            sb.append("    ")

            if(!field.optional) {
                sb.append("required ")
            }

            sb.append("this.${field.name},")

        }.toString()

}

/**
 * Prints the factory method.
 *
 * @author Gillian Buijs
 */
internal class FactoryPrinter(
    private val message: DartMessage
): KlutterPrinter {

    override fun print() = "" +
            "| factory ${message.name}.fromJson(dynamic json) {$BR" +
            "   return ${message.name} ($BR" +
            "${message.fields.joinToString(BR) { printField(it) }}$BR" +
            "   );$BR" +
            " }"


    private fun printField(field: DartField) =
        StringBuilder().also { sb ->

            val isCustomDataType = field.customDataType != null
            val dataType = toDataType(field)

            sb.append("     ")
            if(field.isList){
                sb.append("${field.name}: ")
                sb.append("List<$dataType>")
                sb.append(".from(json.decode(json['${field.name}'])")
                if(isCustomDataType){
                    sb.append(".map((o) => _$dataType.parse(o)))")
                } else sb.append(".map((o) => o${getCastMethod(dataType)}))")
            } else sb.append("${field.name}: json['${field.name}']")
            sb.append(",")
        }.toString()

    private fun getCastMethod(dataType: String) = when(DartKotlinMap.toMap(dataType)) {
        DartKotlinMap.BOOLEAN -> ".toLowerCase() === 'true'"
        DartKotlinMap.DOUBLE -> ".toDouble()"
        DartKotlinMap.INTEGER -> ".toInt()"
        DartKotlinMap.STRING -> ".toString()"
        else -> throw KlutterCodeGenerationException("Failed to process datatype: $dataType")
    }

}

/**
 * Prints the fields of a class.
 *
 * @author Gillian Buijs
 */
internal class MemberPrinter(
    private val fields: List<DartField>
): KlutterPrinter {

    override fun print() = fields.sortedBy { it.optional }.joinToString(BR) {
        var datatype = toDataType(it)

        if(it.isList){
            datatype = "List<${toDataType(it)}>"
        }

        if(it.optional) {
            " $datatype? ${it.name};"
        } else " final $datatype ${it.name};"
    }

}

/**
 * Prints the toJson method.
 *
 * @author Gillian Buijs
 */
internal class SerializerPrinter(
    private val fields: List<DartField>
): KlutterPrinter {

    override fun print() =
        " Map<String, dynamic> toJson() {$BR" +
        "   return {$BR" +
        "|${fields.joinToString(",$BR") { "     '${it.name}': ${serializer(it)}" }}$BR" +
        "   };$BR" +
        " }"

    private fun serializer(field: DartField): String {
        var out = field.name

        if(field.isList) {

            field.customDataType?.let {

                if(field.isList) {
                    out += ".map((o) => o.toJson())"
                }

            }

            out += ".toList()"
        } else field.customDataType?.let { out = "$out.toJson()" }

        return out
    }
}

internal fun toDataType(field: DartField) = field.customDataType?:field.dataType
